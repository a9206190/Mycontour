//@version=5
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© reees
//@version=5

indicator("è«§æ³¢æª¢æ¸¬","è«§æ³¢æª¢æ¸¬",overlay=true,max_lines_count=500,max_labels_count=500,max_bars_back=500)

import reees/TA/85 as t
import reees/Draw/27 as draw
import reees/Utilities/5 as u
import reees/Pattern/1 as p
import reees/Obj_XABCD_Harmonic/10 as h
//import reees/Algebra/3 as alg

//----------------------------------------- 
// inputs and vars  
//-----------------------------------------

// æ¨¡å¼é¡å‹è¼¸å…¥
var bullOn = input.bool(true, "çœ‹æ¼²", inline="type_b", group="åŒ…å«")
var bearOn = input.bool(true, "çœ‹è·Œ", inline="type_b", group="åŒ…å«")
var incOn = input.bool(true, "æ½›åœ¨/ä¸å®Œæ•´", inline="type_b", group="åŒ…å«")
var hsOn = input.bool(true, "åƒ…é«˜åˆ†", inline="type_b", group="åŒ…å«",tooltip="åƒ…é¡¯ç¤ºç¬¦åˆæ‚¨çš„ã€Œå¦‚æœå¾—åˆ†é«˜æ–¼ã€æ¢ä»¶çš„æ¨¡å¼ã€‚")
var i_lb = input.bool(false,"å›æ¸¬å¤©æ•¸",group="åŒ…å«",inline="h", tooltip="é è¨­æœƒé¡¯ç¤ºæ‰€æœ‰éå¾€è¨˜éŒ„")
var i_lbn = input.int(100,"",group="åŒ…å«",inline="h")
var gartOn = input.bool(true, "åŠ ç‰¹åˆ©:", inline="gart", group="é¡å‹èˆ‡ç›®æ¨™")
var gart_t1 = input.string(".618 AD", "ç›®æ¨™ 1", inline="gart", group="é¡å‹èˆ‡ç›®æ¨™", options=[".382 AD",".5 AD",".618 AD",".382 XA",".5 XA",".618 XA","1.272 XA","1.618 XA",".382 CD",".5 CD",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var gart_t2 = input.string("1.272 AD", "ç›®æ¨™ 2", inline="gart", group="é¡å‹èˆ‡ç›®æ¨™", options=["ç„¡",".618 AD","1.272 AD","1.618 AD",".618 XA","1.272 XA","1.618 XA",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var batOn = input.bool(true, "è™è :", inline="bat", group="é¡å‹èˆ‡ç›®æ¨™")
var bat_t1 = input.string(".618 AD", "ç›®æ¨™ 1", inline="bat", group="é¡å‹èˆ‡ç›®æ¨™", options=[".382 AD",".5 AD",".618 AD",".382 XA",".5 XA",".618 XA","1.272 XA","1.618 XA",".382 CD",".5 CD",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var bat_t2 = input.string("1.272 AD", "ç›®æ¨™ 2", inline="bat", group="é¡å‹èˆ‡ç›®æ¨™", options=["ç„¡",".618 AD","1.272 AD","1.618 AD",".618 XA","1.272 XA","1.618 XA",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var bflyOn = input.bool(true, "è´è¶:", inline="bfly", group="é¡å‹èˆ‡ç›®æ¨™")
var bfly_t1 = input.string(".618 AD", "ç›®æ¨™ 1", inline="bfly", group="é¡å‹èˆ‡ç›®æ¨™", options=[".382 AD",".5 AD",".618 AD",".382 XA",".5 XA",".618 XA","1.272 XA","1.618 XA",".382 CD",".5 CD",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var bfly_t2 = input.string("1.272 AD", "ç›®æ¨™ 2", inline="bfly", group="é¡å‹èˆ‡ç›®æ¨™", options=["ç„¡",".618 AD","1.272 AD","1.618 AD",".618 XA","1.272 XA","1.618 XA",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var crabOn = input.bool(true, "èƒèŸ¹:", inline="crab", group="é¡å‹èˆ‡ç›®æ¨™")
var crab_t1 = input.string(".618 AD", "ç›®æ¨™ 1", inline="crab", group="é¡å‹èˆ‡ç›®æ¨™", options=[".382 AD",".5 AD",".618 AD",".382 XA",".5 XA",".618 XA","1.272 XA","1.618 XA",".382 CD",".5 CD",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var crab_t2 = input.string("1.618 AD", "ç›®æ¨™ 2", inline="crab", group="é¡å‹èˆ‡ç›®æ¨™", options=["ç„¡",".618 AD","1.272 AD","1.618 AD",".618 XA","1.272 XA","1.618 XA",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var sharkOn = input.bool(true, "é¯Šé­š:", inline="shark", group="é¡å‹èˆ‡ç›®æ¨™")
var shark_t1 = input.string(".382 AD", "ç›®æ¨™ 1", inline="shark", group="é¡å‹èˆ‡ç›®æ¨™", options=[".382 AD",".5 AD",".618 AD",".382 XA",".5 XA",".618 XA","1.272 XA","1.618 XA",".382 CD",".5 CD",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var shark_t2 = input.string("C", "ç›®æ¨™ 2", inline="shark", group="é¡å‹èˆ‡ç›®æ¨™", options=["ç„¡",".618 AD","1.272 AD","1.618 AD",".618 XA","1.272 XA","1.618 XA",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var cyphOn = input.bool(true, "è³½ç¦:", inline="cyph", group="é¡å‹èˆ‡ç›®æ¨™")
var cyph_t1 = input.string(".618 CD", "ç›®æ¨™ 1", inline="cyph", group="é¡å‹èˆ‡ç›®æ¨™", options=[".382 AD",".5 AD",".618 AD",".382 XA",".5 XA",".618 XA","1.272 XA","1.618 XA",".382 CD",".5 CD",".618 CD","1.272 CD","1.618 CD","A","B","C"])
var cyph_t2 = input.string("1.618 XA", "ç›®æ¨™ 2", inline="cyph", group="é¡å‹èˆ‡ç›®æ¨™", options=["ç„¡",".618 AD","1.272 AD","1.618 AD",".618 XA","1.272 XA","1.618 XA",".618 CD","1.272 CD","1.618 CD","A","B","C"])
// Entry/Stop Inputs
var e_afterC = input.bool(true,"Cé»é€²å ´",group="é€²å ´/å‡ºå ´")
var e_lvlc = input.string("æœ€è¿‘çš„åŒ¯åˆPRZæ°´å¹³","Â Â Â Â Â Â Â é€²å ´é»",options=["æœ€è¿‘çš„åŒ¯åˆPRZæ°´å¹³","æœ€é åŒ¯åˆ PRZ æ°´å¹³","å…©å€‹åŒ¯åˆ PRZ æ°´å¹³ä¹‹é–“","æœ€è¿‘çš„ PRZ ç´šåˆ¥","æœ€é  PRZ ç´šåˆ¥"],group="é€²å ´/å‡ºå ´")
var e_aboveC = input.float(90,"Â Â Â Â Â Â Â æ•¸å€¼èª¤å·®å€¼",group="é€²å ´/å‡ºå ´",tooltip="åƒ…ç•¶å½¢æ…‹æ•¸å€¼é«˜æ–¼æŒ‡å®šå€¼æ™‚æ‰æœƒé€²è¡Œäº¤æ˜“ã€‚ è«‹æ³¨æ„,åœ¨ C é»ä¹‹å¾Œé€²å…¥äº¤æ˜“æ™‚,æ•¸å€¼ä¸¦ä¸é½Šå…¨,å› æ­¤å°šç„¡æ³•æ¸¬é‡ D é»èˆ‡ PRZ çš„åŒ¯åˆã€‚ å› æ­¤,æœ€çµ‚æ¨¡å¼å¯èƒ½èˆ‡è¼¸å…¥æ™‚çš„æ•¸å€¼ä¸åŒã€‚ å¦‚æœæ‚¨å¸Œæœ›é‡å°æ¯ç¨®å½¢æ…‹é€²è¡Œäº¤æ˜“,è«‹å°‡å…¶è¨­ç‚º 0ã€‚")
var e_afterD = input.bool(true,"Dé»é€²å ´",group="é€²å ´/å‡ºå ´")
var e_lvldPct = input.float(1.0,"Â Â Â Â Â Â Â èˆ‡Dé»èª¤å·®å€¼é™åˆ¶",minval=0.0,step=.1,group="é€²å ´/å‡ºå ´",tooltip="ç¢ºèªæœ‰æ•ˆ D é»å¾Œé€²å…¥äº¤æ˜“,æœ€å¤šç‚ºè· D é»çš„ç™¾åˆ†æ¯”é™åˆ¶ã€‚ å°æ–¼çœ‹æ¼²å½¢æ…‹(å¤šé ­â€‹â€‹å…¥å ´),å¦‚æœè©²å€¼è¨­ç½®ç‚º5%,å‰‡å…¥å ´å°‡åœ¨D é»ä¸Šæ–¹æœ€å¤š5% çš„æœ€ä½³å¯èƒ½åƒ¹æ ¼è™•é€²è¡Œã€‚å ´å°‡è™•æ–¼æœ€å…ˆé”åˆ°çš„æ°´å¹³ã€‚ \n\nå¦‚æœæœªé”åˆ°å…¥é–€ç´šåˆ¥,å‰‡æ¨¡å¼å°‡ä¸æœƒåŒ…å«åœ¨æˆåŠŸç‡å’Œå›å ±ç‡çµ±è¨ˆä¸­ã€‚")
var e_aboveD = input.float(90,"Â Â Â Â Â Â Â æ•¸å€¼èª¤å·®å€¼",group="é€²å ´/å‡ºå ´",tooltip="åƒ…ç•¶å½¢æ…‹å¾—åˆ†é«˜æ–¼æŒ‡å®šå€¼æ™‚æ‰æœƒé€²è¡Œäº¤æ˜“ã€‚ å¦‚æœæ‚¨å¸Œæœ›é‡å°æ¯ç¨®å½¢æ…‹é€²è¡Œäº¤æ˜“,è«‹å°‡å…¶è¨­ç‚º0.")
var e_tLimit = input.float(.5,"Â Â Â Â Â Â Â Entry window (time limit)",group="é€²å ´/å‡ºå ´",tooltip="è¨‚å–®è¼¸å…¥çš„æ™‚é–“é™åˆ¶,ä»¥æ¨¡å¼é•·åº¦æŒ‡å®š(ä¾‹å¦‚â€œ0.5â€è¡¨ç¤ºç¸½æ¨¡å¼é•·åº¦çš„ä¸€åŠ)ã€‚ å¦‚æœåœ¨è¨‚å–®æˆäº¤ä¹‹å‰è¶…éæ™‚é–“é™åˆ¶,è¨‚å–®å°‡è¢«å–æ¶ˆ,ä¸¦ä¸”ä¸æœƒç‚ºè©²å½¢æ…‹è¼¸å…¥ä»»ä½•äº¤æ˜“ã€‚")
var stopPct = input.float(75,"æ­¢æ",step=1.0,minval=0.0,group="é€²å ´/å‡ºå ´",inline="stop")
var stopB = input.string("% è¶…éæ­¢ç›ˆç›®æ¨™1æˆ–é€²å ´é»","",options=["% è¶…éXé»æˆ–Dé»","% è¶…éæœ€é PRZæ°´å¹³","% è¶…éDé»","% è¶…éé€²å ´é»","% è¶…éæ­¢ç›ˆç›®æ¨™1æˆ–é€²å ´é»"],group="é€²å ´/å‡ºå ´",inline="stop",tooltip="å°‡æ­¢æç™¾åˆ†æ¯”è¨­å®šç‚ºè¶…å‡ºæŒ‡å®šæ°´æº–ã€‚ å¦‚æœåƒ¹æ ¼åœ¨è§¸åŠç¬¬ä¸€å€‹ç›®æ¨™ä¹‹å‰æˆ–åœ¨ç›®æ¨™è¶…æ™‚æœŸé™åˆ°æœŸä¹‹å‰é”åˆ°æ­¤æ°´å¹³,å‰‡è©²å½¢æ…‹å°‡è¢«è¦–ç‚ºå¤±æ•—ã€‚ç™¾åˆ†æ¯”,ä»¥å…©è€…ç‚ºæº–è·æ¢ç›®æ›´é \n\nâ€œåˆ°ç›®æ¨™1 çš„è·é›¢çš„%â€= å¾æ¢ç›®ç´šåˆ¥åˆ°ç›®æ¨™1 çš„è·é›¢çš„ç™¾åˆ†æ¯”ã€‚ \n\nâ€œè¶…å‡ºæ¢ç›®çš„%â€= é«˜æ–¼/ä½æ–¼æ¢ç›®ç´šåˆ¥çš„ç™¾åˆ†æ¯”ã€‚ \n\n'è¶…å‡º D é»çš„ç™¾åˆ†æ¯”' = é«˜æ–¼/ä½æ–¼ D é»çš„ç™¾åˆ†æ¯”ã€‚")
// Pattern Inputs
var t_b = input.int(1,"æ¨¡å¼é•·åº¦é©—è­‰(#å°¾éš¨æ¢)",minval=1,group="Pattern",tooltip="åœ¨æŸä¸€å½¢æ…‹è¢«è¦–ç‚ºæœ‰æ•ˆä¹‹å‰,æ½›åœ¨åè½‰Dé»(æˆ–ä¸å®Œæ•´å½¢æ…‹çš„ C é»)ä¹‹å¾Œçš„æŸ±æ•¸ã€‚ é€™æœƒå½±éŸ¿ç¹ªè£½åœ–æ¡ˆå’Œæ”¾ç½®æ¢ç›®çš„é€Ÿåº¦ã€‚")
var pctErr = input.float(15.0,"å…è¨±æ–æ³¢èª¤å·®å€¼ %",step=1.0,minval=0.0,maxval=50.0,group="Pattern",inline="err")
var pctAsym = input.float(250.0,"å…è¨±çš„Dé»çš„èª¤å·®å€¼ %",step=1.0,minval=0.0,maxval=1000.0,group="Pattern",inline="asym",tooltip="å¦‚æœä¸€é‚Šçš„é•·åº¦åœ¨è©²å½¢æ…‹ä¸­å…¶ä»–é‚Šçš„å¹³å‡é•·åº¦çš„ç™¾åˆ†æ¯”ç¯„åœå…§,å‰‡è©²é‚Šè¢«è¦–ç‚ºæœ‰æ•ˆã€‚")
var w_e = input.float(4.0,"Weight",step=.1,minval=0.0,group="Pattern",inline="err",tooltip="å¦‚æœä¸€æ¢è…¿çš„å›æ’¤æ¯”ç‡åœ¨å®šç¾©çš„è«§æ³¢ç™¾åˆ†æ¯”ç¯„åœå…§,å‰‡è©²è…¿è¢«è¦–ç‚ºæœ‰æ•ˆã€‚ æ¬Šé‡æ±ºå®šäº†æ¨¡å¼ç¸½åˆ†è¨ˆç®—ä¸­å›æ’¤ç™¾åˆ†æ¯”èª¤å·®çš„æ¬Šé‡ã€‚")
//var w_a = input.float(0.0,"Weight",step=.1,minval=0.0,group="Pattern",inline="asym",tooltip="A leg is considered valid if its length (Î”X/number of bars) is within this % of the average length of the other legs in the pattern. Weight determines the weight of length asymmetry in the total score calculation for a pattern.")
var tLimitMult = input.float(3,"æ¨¡å¼æ™‚é–“é™åˆ¶",group="Pattern",step=.1,minval=.1,tooltip="å·²å®Œæˆæ¨¡å¼é”åˆ°é æœŸç›®æ¨™çš„æ™‚é–“é™åˆ¶ã€‚ å€¼ä»¥ç¸½æ¨¡å¼é•·åº¦(é» X åˆ°é» D)ä¾†æŒ‡å®š,å³å€¼ 1 å°‡å…è¨±åœ¨æ¨¡å¼é€¾æ™‚ä¹‹å‰ç¶“éä¸€å€‹æ¨¡å¼é•·åº¦,ä¸¦ä¸”ä¸å†è¢«è¦–ç‚ºæˆåŠŸã€‚ è¶…æ™‚çš„æ¨¡å¼å°‡ä¸è¨ˆå…¥çµæœè¡¨ä¸­çš„æˆåŠŸç‡ã€‚")
var w_p = input.float(2.0,"PRZæ°´å¹³åŒ¹é…çš„æ¬Šé‡",step=.1,minval=0.0,group="Pattern",tooltip="åœ¨æ¨¡å¼ç¸½åˆ†è¨ˆç®—ä¸­æ‡‰ç”¨æ–¼æ½›åœ¨åè½‰å€å°çº–ç¶­æ°´å¹³åŒ¯åˆçš„æ¬Šé‡ã€‚ å…©å€‹æœ€æ¥è¿‘çš„ PRZ æ–æ³¢æ°´å¹³è¶Šæ¥è¿‘,å¾—åˆ†å°±è¶Šé«˜ã€‚")
var w_d = input.float(3.0,"Dé»èˆ‡PRZæ°´å¹³çš„åŒ¹é…æ¬Šé‡",step=.1,minval=0.0,group="Pattern",tooltip="æ¬Šé‡æ‡‰ç”¨æ–¼å½¢æ…‹ç¸½åˆ†è¨ˆç®—ä¸­ D é»èˆ‡æ½›åœ¨åè½‰å€æ°´æº–çš„åŒ¯åˆè™•ã€‚ D é»è·é›¢å…©å€‹åŒ¯åˆ PRZ æ–æ³¢ç­‰ç´šä¸­çš„ä»»ä½•ä¸€å€‹è¶Šè¿‘,åˆ†æ•¸è¶Šé«˜ã€‚")

// Alert Inputs
//var a_on = input.bool(true, "Alert", inline="alert", group="Alerts")
var a_type = input.string("å…¨éƒ¨", "é æ¸¬", options=["æ½›åœ¨å½¢æ…‹","å®Œæ•´å½¢æ…‹","å…¨éƒ¨"], inline="æé†’", group="é æ¸¬")

// Display Inputs
var c_bline = input.color(color.new(color.green,20), "çœ‹æ¼²è·¯å¾‘", group="Display")
var c_beline = input.color(color.new(color.red, 20), "çœ‹è·Œè·¯å¾‘", group="Display")
var c_blab = input.color(color.new(color.green,75), "çœ‹æ¼²æ¨™ç±¤", group="Display")
var c_belab = input.color(color.new(color.red,75), "çœ‹è·Œæ¨™ç±¤", group="Display")
var l_txt = input.color(color.new(color.white,20), "æ¨™ç±¤æ–‡å­—", group="Display")

var int[] includeTps = array.new_int()
if barstate.isfirst
    if gartOn
        array.push(includeTps,1)
    if batOn
        array.push(includeTps,2)
    if bflyOn
        array.push(includeTps,3)
    if crabOn
        array.push(includeTps,4)
    if sharkOn
        array.push(includeTps,5)
    if cyphOn
        array.push(includeTps,6)
var h.harmonic_params params = h.init_params(pctErr,pctAsym,includeTps,w_e,w_p,w_d)     // scoring and validation parameters for xabcd_harmonic objects

// xabcd_harmonic object pointers
var h.xabcd_harmonic[] bullGart = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bullBat = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bullBfly = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bullCrab = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bullShark = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bullCyph = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bearGart = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bearBat = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bearBfly = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bearCrab = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bearShark = array.new<h.xabcd_harmonic>()
var h.xabcd_harmonic[] bearCyph = array.new<h.xabcd_harmonic>()
// var int[] lastX = array.new_int(5,0)

// temp/last/incomplete pattern structures
var h.xabcd_harmonic[] pending = array.new<h.xabcd_harmonic>()
var label[] fullIpL = array.new_label(0)
var line[] fullIpLn = array.new_line(0)
var linefill[] fullIpLf = array.new_linefill(0)
var h.xabcd_harmonic[] inc = array.new<h.xabcd_harmonic>()
var int[] inc_lastX = array.new_int(4,0)

// Stat totals
var int[] pTot = array.new_int(0)
var int[] tTot = array.new_int(0)
var float[] t1Tot = array.new_float(0)
var float[] t2Tot = array.new_float(0)
var float[] arTot = array.new_float(0)
var float[] trTot = array.new_float(0)

//-----------------------------------------
// functions
//-----------------------------------------

// Type of harmonic pat
// Assumes pattern is complete, and therefore only one can be true
tp(h1,h2,h3,h4,h5,h6) =>
    switch
        h1 => 1
        h2 => 2
        h3 => 3
        h4 => 4
        h5 => 5
        => 6

nToArray(n) =>
    switch n
        "a1" => bullGart
        "a2" => bullBat
        "a3" => bullBfly
        "a4" => bullCrab
        "a5" => bullShark
        "a6" => bullCyph
        "b1" => bearGart
        "b2" => bearBat
        "b3" => bearBfly
        "b4" => bearCrab
        "b5" => bearShark
        "b6" => bearCyph

typeToArray(t,tp) =>
    n = (t ? "a" : "b") + str.tostring(tp)
    nToArray(n)

t1(tp) =>
    switch tp
        6 => cyph_t1
        5 => shark_t1
        4 => crab_t1
        3 => bfly_t1
        2 => bat_t1
        => gart_t1

t2(tp) =>
    switch tp
        6 => cyph_t2
        5 => shark_t2
        4 => crab_t2
        3 => bfly_t2
        2 => bat_t2
        => gart_t2

// get target
targets(tp) =>
    [t1(tp),t2(tp)]

harmonic_xabcd_targets(tp,xY,aY,bY,cY,dY) =>
    tgt1 = t1(tp)
    tgt2 = t2(tp)
    [t1,t2,_] = t.harmonic_xabcd_targets(xY,aY,bY,cY,dY,tgt1,tgt2)
    [t1,t2]

// Timeout period
tLimit(xX,dX) =>
    int((dX - xX)*tLimitMult)

incTLimit(xX,cX) =>
    avg = (cX-xX)/3
    int(avg * (1 + pctAsym/100))    // time out after max possible bars based on asymmetry parameter

// Entry has timed out
eTimeout(xX,dX) =>
    bar_index - dX > int((dX - xX)*e_tLimit)

// Pattern still active within timeout period
stillActive(xX,dX) =>
    bar_index - tLimit(xX,dX) <= dX and eTimeout(xX,dX) == false

// make sure score is high enough to enter a trade
noEntry(h.xabcd_harmonic p) =>
    not na(p.d.x) ? p.score < (e_aboveD/100) : p.score < (e_aboveC/100)

entry(p) =>
    if noEntry(p)
        [na,na,na]
    else
        t.harmonic_xabcd_entry(p.bull,p.tp,p.x.y,p.a.y,p.b.y,p.c.y,p.d.y,e_afterC,e_lvlc,e_afterD,e_lvldPct)

// Determine if entry level was reached
entryHit(p) =>
    if p.eHit or p.eHit == false
        [p.eHit,p.e.x,p.e.y]
    else if (not na(p.d.x) and eTimeout(p.x.x,p.d.x)) or noEntry(p)
        [false,na,na]
    else
        [_,afterC,afterD] = entry(p)
        [eH,eX,eY] = t.xabcd_entryHit(p.bull, afterC, afterD, p.d.x, e_afterC, e_afterD, t_b)
        if not na(eY) and ((p.bull and p.t1<eY) or (p.bull==false and p.t1>eY))
            [na,na,na]
        else
            [eH==false?na:eH,eX,eY]

// Determine if pattern has succeeded or failed, or neither (na)
success(p) =>
    // if stop or target 2 already hit, nothing to check
    if p.sHit or p.t2Hit
        [p.t1Hit,p.t2Hit,p.sHit,na,na,na,na]
    // if within time limit and trade active / entry hit, check targets/stop
    else if bar_index <= (p.d.x + tLimit(p.x.x,p.d.x)) and p.eHit
        t.tradeClosed(p.e.x,p.e.y,p.stop,p.t1Hit,p.t2Hit,p.t1,p.t2)
    // else nothing to update
    else
        [p.t1Hit,p.t2Hit,p.sHit,na,na,na,na]

alertMsg(p) =>
    if na(p.d.x)
        "æ½›åœ¨çš„ " + h.get_name(p) + " æ­£åœ¨å½¢æˆ."
    else
        h.get_name(p) + " å·²ç¶“å½¢æˆ."

deleteFip() =>
    for lbl in fullIpL
        label.delete(lbl)
    array.clear(fullIpL)
    //
    for ln in fullIpLn
        line.delete(ln)
    array.clear(fullIpLn)
    //
    for lf in fullIpLf
        linefill.delete(lf)
    array.clear(fullIpLf)

removePending(pid) =>
    if array.size(pending) > 0
        for i=0 to array.size(pending)-1
            p = array.get(pending,i)
            if p.pid == pid
                if i == array.size(pending)-1
                    deleteFip()
                array.remove(pending,i)
                break

successTxt(p) =>
    if p.t2Hit
        " (æˆåŠŸ - ç›®æ¨™ 1, ç›®æ¨™ 2)"
    else if p.t1Hit
        " (æˆåŠŸ - ç›®æ¨™ 1)"
    else if p.sHit
        " (å¤±æ•—)"
    else if noEntry(p) and stillActive(p.x.x,p.d.x)
        " (æœªé€²å ´)"
    else if (p.eHit==false or na(p.eHit)) and stillActive(p.x.x,p.d.x) == false
        " (éŒ¯é)"
    else if na(p.eHit) and stillActive(p.x.x,p.d.x)
        " (æ›å–®ä¸­)"
    else if na(p.t1Hit) and stillActive(p.x.x,p.d.x)
        " (ç­‰å¾…çµæœ)"
    else
        " (é€¾æ™‚)"

ratToStr(r) =>
    na(r) ? "NA    " : str.tostring(r, "0.000")

reToStr(r) =>
    na(r) ? "NA    " : str.tostring(r, "0.0") + "%"

// Pattern tooltip
ttTxt(p) =>
    [rb,rc,rd1,rd2] = t.harmonic_xabcd_fibDispTxt(p.tp)
    [_,_,e] = entry(p)
    l1 = h.get_name(p) + successTxt(p) + "\n\n"
    l2 = (p.invalid_d?"Incomplete":"Total") + " Score:  " + str.tostring(p.score*100,"#.###") + "\n"
    l3 = "   è…³çš„å›æ¸¬ç²¾åº¦:  " + str.tostring((1-p.score_eAvg)*100, "#.##") + "%\n"
    l42 = "   PRZæ°´å¹³åŒ¯èš:  " + (p.tp==6 ? "NA" : (str.tostring(p.score_prz*100, "#.##") + "%")) + "\n"
    l43 = "   Dé»èˆ‡PRZçš„åŒ¯èš:  " + (p.invalid_d?"NA (D unconfirmed)":str.tostring((1-p.score_eD)*100, "#.##") + "%") +"\n"
    l5 = "\n              å¯¦éš›æ•¸å€¼     % Err       ç†æƒ³æ•¸å€¼\n"
    l6 = "AB/XA     " + str.tostring(p.r_xb, "0.000") + "      " + (p.tp==5 ? "NA     " : (str.tostring(p.re_xb*100, "00.0")+"%")) + "      " + rb + "\n"
    l7 = "BC/AB     " + str.tostring(p.r_ac, "0.000") + "      " + str.tostring(p.re_ac*100, "00.0") + "%      " + rc + "\n"
    l8 = "CD/BC     " + ratToStr(p.r_bd) + "      " + (p.tp==6 ? "NA    " : reToStr(p.re_bd*100)) + "       " + rd1 + "\n"
    l9 = (p.tp==6 ? "CD/XC     " : "AD/XA     ") + ratToStr(p.r_xd) + "      " + reToStr(p.re_xd*100) + "       " + rd2 + "\n"
    l91 = "\ç›®æ¨™åƒ¹ä½ 1:  " + str.tostring(p.t1,"#.#####") + "   \ç›®æ¨™åƒ¹ä½ 2:  " + str.tostring(p.t2,"#.#####")
    l92 = "\é€²å ´:  " + str.tostring(na(p.e.y)?e:p.e.y,"#.#####")
    l93 = na(p.stop) ? "" : "    \æ­¢æ:  " + str.tostring(p.stop,"#.#####" + "\n")
    l1 + l2 + l3 + l42 + l43 + l5 + l6 + l7 + l8 + l9 + l92 + l93 + l91

status(p) =>
    if p.t2Hit
        " âœ…âœ…"
    else if p.t1Hit
        " âœ…"
    else if p.sHit
        " âŒ"
    else if stillActive(p.x.x,p.d.x) == false and (p.eHit == false or na(p.eHit))
        " â›”"
    else if stillActive(p.x.x,p.d.x) and noEntry(p)
        " â›”"
    else if stillActive(p.x.x,p.d.x)
        " â³"
    else
        " ğŸ•"
        
lbTxt(p,status) =>
    t.harmonic_xabcd_symbol(p.tp) + " " + str.tostring(math.round(p.score,3)*100) + status

incLbTxt(p) =>
    "æ½›åœ¨ " + t.harmonic_xabcd_symbol(p.tp) + " (" + str.tostring(p.score*100,"#.##") + ")"

erasePattern(p) =>
    h.erase_pattern(p)
    h.erase_label(p)

deleteInc(string pid) =>
    n = array.size(inc)
    if not na(pid) and n > 0
        for j=0 to n-1
            p = array.get(inc,j)
            if pid == p.pid
                array.remove(inc,j)
                erasePattern(p)
                break

drawPattern(p) =>
    if incOn or not na(p.d.x)
        status = status(p)
        lbTxt = not na(p.d.x) ? lbTxt(p,status) : incLbTxt(p)
        [_,e,_] = entry(p)
        tt = not na(p.d.x) ? ttTxt(p) : draw.incTtTxt(p.tp,h.get_name(p),p.r_xb,p.re_xb,p.r_ac,p.re_ac,p.prz_bN,p.prz_bF,p.prz_xN,p.prz_xF,p.score,e)
        h.draw_pattern(p, p.bull?c_bline:c_beline)
        if p.invalid_d
            line.set_style(array.get(p.pLines,3),line.style_dashed)
        h.draw_label(p, p.bull?c_blab:c_belab, l_txt, lbTxt, tt)

lowest(n, o=0) =>
    if n >= o
        v = low[o]
        for i=o to n
            if low[i] < v
                v := low[i]
        v

highest(n, o=0) =>
    if n >= o
        v = high[o]
        for i=o to n
            if high[i] > v
                v := high[i]
        v

notLast(p) =>   // check if not same pattern as last completed pattern of same type
    comp = typeToArray(p.bull,p.tp)
    h.xabcd_harmonic last = array.size(comp) == 0 ? na : array.get(comp,array.size(comp)-1)
    na(last) ? true : last.x.x!=p.x.x or last.a.x!=p.a.x or last.b.x!=p.b.x

addIncompletePattern(t,h1,h2,h3,h4,h5,h6,xX,xY,aX,aY,bX,bY,cX,cY) =>
    btps = array.from(h1,h2,h3,h4,h5,h6)
    tps = u.boolToIntArr(btps)
    lowest = lowest(bar_index-cX)
    highest = highest(bar_index-cX)
    int dX = na
    float dY = na
    // check if pattern already exists (incomplete or pending)
    exists = false
    iN = array.size(inc)
    iP = array.size(pending)
    if iN > 0
        for i=0 to iN-1
            p = array.get(inc,iN-1-i)       // more likely to find it at top of stack
            if p.x.x==xX and p.a.x==aX and p.b.x==bX
                if p.c.x == cX
                    exists := true
                else
                    // if new point C, delete the old inc pattern in favor of this one
                    array.remove(inc,iN-1-i)
                    erasePattern(p)
                break
    if exists==false and iP > 0
        for i=0 to iP-1
            p = array.get(pending,iP-1-i)
            if p.x.x==xX and p.a.x==aX and p.b.x==bX and p.c.x==cX
                exists := true
                break
    
    if exists == false
        // add separate incomplete pattern for each potential harmonic type
        for tpe in tps
            tp = tpe+1
            if exists == false
                pat = h.init(xX,xY,aX,aY,bX,bY,cX,cY,dX,dY,params,tp)
                if not na(pat)
                    [_,eC,_] = entry(pat)
                    if na(eC) or (not na(eC) and ((t and eC < lowest) or (t==false and eC > highest)))
                        if notLast(pat)
                            array.push(inc,pat)
                            if incOn and (not na(eC) or not e_afterC)
                                drawPattern(pat)
                            if a_type == "æ½›åœ¨æ¨¡å¼" or a_type == "å…¨éƒ¨"
                                alert(alertMsg(pat),alert.freq_once_per_bar_close) // temporarily changing to fire on bar close until real-time bar multiple alert issue is resolved

setTargets(p) =>
    [t1,t2] = targets(p.tp)
    h.set_target(p,1,calc_target=t1)
    h.set_target(p,2,calc_target=t2)

incPid(p) =>
	str.tostring(p.tp) + "_"
     + str.tostring(p.x.x) + "_"
     + str.tostring(p.a.x) + "_"
     + str.tostring(p.b.x) + "_"
     + str.tostring(p.c.x) + "_"
     + str.tostring(na)

// Draw completed pattern and update data structures
addCompleted(p,force=false) =>
    if hsOn==false or noEntry(p)==false
        a = typeToArray(p.bull,p.tp)   
        array.push(a,p)  // add pattern
        // check if we need to delete incomplete pattern, only if not already adding from an incomplete pattern and allowing entry after D
        // (otherwise keep incomplete pattern to continue checking for entry after C)
        if force == false
            if e_afterD
                deleteInc(incPid(p))
            p.invalid_d := false
        setTargets(p)
        drawPattern(p)
        [upper,lower] = t.harmonic_xabcd_przRange(p.prz_bN,p.prz_bF,p.prz_xN,p.prz_xF)
        p.stop := t.harmonic_xabcd_stop(stopB,stopPct,p.bull,p.x.y,p.d.y,upper,lower,p.t1,p.e.y)
        if noEntry(p)==false
            array.push(pending,p)
        // fire alert if appropriate
        if a_type == "å®Œæ•´å½¢æ…‹" or a_type == "å…¨éƒ¨"
            alert(alertMsg(p),alert.freq_once_per_bar_close) // temporarily changing to fire on bar close until real-time bar multiple alert issue is resolved

// Add pattern to completed pattern structures
addValidPattern(p,force=false) =>
    bool lasteH = na
    float lastScore = na
    h.xabcd_harmonic pat = na
    a = typeToArray(p.bull,p.tp)
    if array.size(a) > 0
        // check last pattern of same type
        last = array.get(a,array.size(a)-1)
        lastScore := last.score
        // if A, B or C is different = new pattern
        if p.a.x!=last.a.x or p.b.x!=last.b.x or p.c.x!=last.c.x
            addCompleted(p,force)
            pat := p        
        // if ABC are same but D is beyond last pattern's D, replace it with this one. We want to draw the
        // new/updated pattern and calculate its updated score, but maintain any entry/targets that have
        // already been hit.
        else if (p.bull and p.d.y < last.d.y) or (p.bull==false and p.d.y > last.d.y)
            if (last.score <= p.score) or force or last.invalid_d // update if new pattern has a higher score, last pattern had invalid D, or forcing from entry After Point C
                if last.eHit                                       // IF last pattern entry was already hit, use the last pattern
                    lasteH := true
                    if force==false
                        last.invalid_d := false
                    h.init(last.x.x,last.x.y,last.a.x,last.a.y,last.b.x,last.b.y,last.c.x,last.c.y,p.d.x,p.d.y,params,last.tp,last)
                    [upper,lower] = t.harmonic_xabcd_przRange(last.prz_bN,last.prz_bF,last.prz_xN,last.prz_xF)
                    last.stop := t.harmonic_xabcd_stop(stopB,stopPct,last.bull,last.x.y,last.d.y,upper,lower,last.t1,last.e.y)
                    drawPattern(last)                   // redraw with new D
                    setTargets(last)                    // reset targets for new D
                    pat := last
                else                                // ELSE, replace last pattern with the new pattern
                    removePending(last.pid)
                    erasePattern(array.pop(a))
                    addCompleted(p,force)
                    pat := p
    else
        addCompleted(p,force)
        pat := p

    // Update newly added pattern
    if not na(pat)
        // update entry, if necessary
        if lasteH
            draw.eHitLbl(pat.e.x,pat.e.y,pat.d.x,pat.d.y,p.bull,true)
        else
            [eHit,eX,eY] = entryHit(p)
            if eHit
                pat.eHit := true
                pat.e.x := eX
                pat.e.y := eY
                draw.eHitLbl(eX,eY,pat.d.x,pat.d.y,pat.bull)
                h.draw_label(p, p.bull?c_blab:c_belab, l_txt, lbTxt(p,status(p)), ttTxt(p))
        ""
        
updatePendingPatterns() =>
    h.xabcd_harmonic[] new = array.new<h.xabcd_harmonic>()
    if array.size(pending) > 0
        for i=0 to array.size(pending)-1
            ip = array.get(pending,i)
            [eH,eHx,eHy] = entryHit(ip)
            tLimit = tLimit(ip.x.x,ip.d.x)
            expired = bar_index == (ip.d.x + tLimit + 1) or eH==false
            [t1h,t2h,sH,t1x,t1y,t2x,t2y] = success(ip)
            // if time has expired or there's nothing left to update, no longer pending
            if not (expired or (eH and (not na(t2h) or t1h == false or sH)))
                array.push(new,ip)
            // if anything to update, update completed array entry and label if necessary            
            if expired 
             or (eH
                 and ((not na(t1h) and na(ip.t1Hit)) or (not na(t2h) and na(ip.t2Hit)))) 
             or (eH != ip.eHit) or (eH and na(ip.eHit)) or (eH==false and na(ip.eHit)) 
             or sH
                if (eH or eH==false) and na(ip.eHit)
                    ip.eHit := eH
                    ip.e.x := eHx
                    ip.e.y := eHy            
                    draw.eHitLbl(eHx,eHy,ip.d.x,ip.d.y,ip.bull)
                // targets will be na if eH==false, so no need to also check eH 
                if t1h and na(ip.t1Hit)
                    ip.t1Hit := true
                    draw.tHitLbl(t1x,t1y,eHx,eHy,ip.bull)
                else if t1h == false
                    ip.t1Hit := false
                    draw.sHitLbl(t1x,t1y,eHx,eHy,ip.bull)   // only draw stop X if no target was already hit
                if sH
                    ip.sHit := true
                    //draw.sHitLbl(bar_index,ip.stop,eHx,eHy,ip.bull)
                if t2h
                    ip.t2Hit := true
                    draw.tHitLbl(t2x,t2y,eHx,eHy,ip.bull)
                h.draw_label(ip, ip.bull?c_blab:c_belab, l_txt, lbTxt(ip,status(ip)), ttTxt(ip))
    new

updateIncompletePatterns() =>
    h.xabcd_harmonic[] new = array.new<h.xabcd_harmonic>()
    if array.size(inc) > 0
        for p in inc
            [upper,lower] = t.harmonic_xabcd_przRange(p.prz_bN,p.prz_bF,p.prz_xN,p.prz_xF)
            tLimit = incTLimit(p.x.x,p.c.x)
            [eH,eHx,eHy] = entryHit(p)
            if eH and e_afterC
                if notLast(p)
                    p.d.x := eHx
                    p.d.y := eHy
                    p.invalid_d := true
                    erasePattern(p)
                    addValidPattern(p,true)
                else
                    erasePattern(p)
            // Don't keep incomplete pattern if it's timed out or has been invalidated
            else if bar_index == (p.c.x + tLimit + 1)
                     or (p.bull and (high > p.c.y or low < lower))
                     or (p.bull==false and (low < p.c.y or high > upper))
                erasePattern(p)
            else
                array.push(new,p)
    new

drawFullInProgress() =>
    if array.size(pending) > 0
        last = array.get(pending,array.size(pending)-1)
        if not na(last.d.x)
            bb = last_bar_index - last.d.x
            tLimit = tLimit(last.x.x,last.d.x)
                                                                            // Only draw if...
            if bb <= tLimit                                                 // within pattern time limit and
               and noEntry(last)==false                                     // entry is possible and
               and (eTimeout(last.x.x,last.d.x)==false or last.eHit)        // entry has not timed out and
               //and (na(last.t1Hit) or (last.t1Hit and na(last.t2Hit)))
               and not last.t2Hit                                           // targets remain to be hit and
               and not last.sHit                                            // stop has not been hit
                deleteFip()                 // delete previously drawn completed pattern in progress
                [highest,lowest] = t.harmonic_xabcd_przRange(last.prz_bN,last.prz_bF,last.prz_xN,last.prz_xF)
                [bcNt,_] = harmonic_xabcd_targets(last.tp,last.x.y,last.a.y,last.b.y,last.c.y,last.prz_bN)
                [bcFt,_] = harmonic_xabcd_targets(last.tp,last.x.y,last.a.y,last.b.y,last.c.y,last.prz_bF)
                [xaNt,_] = harmonic_xabcd_targets(last.tp,last.x.y,last.a.y,last.b.y,last.c.y,last.prz_xN)
                [xaFt,_] = harmonic_xabcd_targets(last.tp,last.x.y,last.a.y,last.b.y,last.c.y,last.prz_xF)
                stop = last.stop
                [e,_,_] = entry(last)
                entry = na(last.e.y) ? e : last.e.y
                [ln,lb,lf] = draw.xabcd_inProgress(last.bull,last.tp,tLimit>500?500:tLimit,entry,stop,last.t1,last.t2,bcNt,bcFt,xaNt,xaFt,
                                                   last.x.x,last.x.y,last.a.y,last.b.x,last.b.y,last.c.y,last.d.x,last.d.y,c_bline,c_beline,l_txt)
                for l in ln
                    array.push(fullIpLn,l)
                for l in lb
                    array.push(fullIpL,l)
                for l in lf
                    array.push(fullIpLf,l)
            else
                deleteFip()
    else
        deleteFip()

rowValues(tp) =>
    a1 = typeToArray(true,tp)
    a2 = typeToArray(false,tp)
    float[] ra = array.new_float(0)
    t1_tot = 0
    t2_tot = 0
    closed = 0
    if array.size(a1) > 0
        for p in a1
            if (not na(p.t1Hit) or p.sHit) and p.eHit
                if p.t2Hit
                    r = (p.t2/p.e.y) - 1
                    array.push(ra,r)
                    t2_tot+=1
                    t1_tot+=1
                    closed+=1
                else if p.t1Hit
                    r = (p.t1/p.e.y) - 1
                    array.push(ra,r)
                    t1_tot+=1
                    closed+=1
                else if p.sHit
                    r = (p.stop/p.e.y) - 1
                    array.push(ra,r)
                    closed+=1
    //for p in a2
    if array.size(a2) > 0
        for p in a2
            if (not na(p.t1Hit) or p.sHit) and p.eHit
                if p.t2Hit
                    r = (p.e.y/p.t2) - 1
                    array.push(ra,r)
                    t2_tot+=1
                    t1_tot+=1
                    closed+=1
                else if p.t1Hit
                    r = (p.e.y/p.t1) - 1
                    array.push(ra,r)
                    t1_tot+=1
                    closed+=1
                else if p.sHit
                    r = (p.e.y/p.stop) - 1
                    array.push(ra,r)
                    closed+=1
    tot = array.size(a1) + array.size(a2)
    array.push(pTot,tot)
    array.push(tTot,closed)
    if closed > 0
        array.push(t1Tot,(t1_tot/closed)*100)
        array.push(t2Tot,(t2_tot/closed)*100)
    if not na(array.avg(ra))
        array.push(arTot,array.avg(ra)*100)
    if not na(array.sum(ra))
        array.push(trTot,array.sum(ra)*100)
    st1 = closed>0 ? str.tostring((t1_tot/closed)*100,"#.##")+"%" : "NA"
    st2 = closed>0 ? str.tostring((t2_tot/closed)*100,"#.##")+"%" : "NA"
    ravg = not na(array.avg(ra)) ? str.tostring(array.avg(ra)*100,"#.##")+"%" : "NA"
    rtot = not na(array.sum(ra)) ? str.tostring(array.sum(ra)*100,"#.##")+"%" : "NA"

    [str.tostring(tot),str.tostring(closed),st1,st2,ravg,rtot]

printStats() =>
    if barstate.islast
        nR = array.size(includeTps) + 3
        r = 0
        t = table.new(position.bottom_left, 7, nR, bgcolor = color.new(color.black,30), border_width = 1)
        table.cell(t, 0, 0, " ", text_color=color.white, text_halign=text.align_center)
        table.cell(t, 1, 0, "Patterns", text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 2, 0, "Trades", text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 3, 0, "æ­¢ç›ˆ1å‹ç‡", text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 4, 0, "æ­¢ç›ˆ2å‹ç‡", text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 5, 0, "å¹³å‡å‹ç‡ %", text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 6, 0, "ç¸½å‹ç‡ %", text_color=color.white, text_halign=text.align_center,text_size=size.small)        
        for tp in includeTps
            r+=1
            [tot,trd,st1,st2,ar,tr] = rowValues(tp)
            table.cell(t, 0, r, "   "+t.harmonic_xabcd_symbol(tp)+"   ", text_color=color.white, text_halign=text.align_center,text_size=size.small)
            table.cell(t, 1, r, tot, text_color=color.white, text_halign=text.align_center,text_size=size.small)
            table.cell(t, 2, r, trd, text_color=color.white, text_halign=text.align_center,text_size=size.small)
            table.cell(t, 3, r, st1, text_color=color.white, text_halign=text.align_center,text_size=size.small)
            table.cell(t, 4, r, st2, text_color=color.white, text_halign=text.align_center,text_size=size.small)
            table.cell(t, 5, r, ar, text_color=color.white, text_halign=text.align_center,text_size=size.small)
            table.cell(t, 6, r, tr, text_color=color.white, text_halign=text.align_center,text_size=size.small)

        r+=1
        t1Total = not na(array.avg(t1Tot)) ? (str.tostring(array.avg(t1Tot),"#.##") + "%") : "Null"
        t2Total = not na(array.avg(t2Tot)) ? (str.tostring(array.avg(t2Tot),"#.##") + "%") : "Null"
        arTotal = not na(array.avg(arTot)) ? (str.tostring(array.avg(arTot),"#.##") + "%") : "Null"
        trTotal = not na(array.sum(trTot)) ? (str.tostring(array.sum(trTot),"#.##") + "%") : "Null"
        table.cell(t, 0, r, "ç¸½è¨ˆ", text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 1, r, str.tostring(array.sum(pTot)), text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 2, r, str.tostring(array.sum(tTot)), text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 3, r, t1Total, text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 4, r, t2Total, text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 5, r, arTotal, text_color=color.white, text_halign=text.align_center,text_size=size.small)
        table.cell(t, 6, r, trTotal, text_color=color.white, text_halign=text.align_center,text_size=size.small)
        r+=1
        keyTxt = "âœ… = æˆåŠŸ | âŒ = å¤±æ•— | ğŸ• = è¶…æ™‚ | â›” = æœªé€²å ´ | â³ = é€²è¡Œä¸­ \n*ä¸åŒ…å«åœ¨æˆåŠŸç‡/å›å ±ç‡çµ±è¨ˆä¸­â€"
        table.cell(t, 0, r, keyTxt, text_color=color.white, text_halign=text.align_right, text_size=size.small)
        table.merge_cells(t,0,r,6,r)
        array.clear(pTot),array.clear(tTot),array.clear(t1Tot),array.clear(t2Tot),array.clear(arTot),array.clear(trTot)

validD(p,dX,dY) =>
    // If CD has valid length symmetry...
    if dX <= (incTLimit(p.x.x,p.c.x) + p.c.x)
        if t.pat_xabcd_testSym(p.a.x-p.x.x, p.b.x-p.a.x, p.c.x-p.b.x, p.d.x-p.c.x, pctAsym)
            highest = highest(bar_index-p.c.x,1)
            lowest = lowest(bar_index-p.c.x,1)
            // If no intermediate high/low invalidates the CD leg...
            if ((p.bull and dY <= lowest) or (p.bull==false and dY >= highest)) 
             and ((p.bull and p.c.y >= highest) or (p.bull==false and p.c.y <= lowest))
                // validate CD retracement for this pattern type
                xa = math.abs(p.x.y - p.a.y)
                bc = math.abs(p.b.y - p.c.y)
                cd = math.abs(p.c.y - dY)
                ad = math.abs(p.a.y - dY)
                xc = math.abs(p.x.y - p.c.y)
                tp = p.tp
                p_types = switch tp
                    1 => array.from(true,false,false,false,false,false)
                    2 => array.from(false,true,false,false,false,false)
                    3 => array.from(false,false,true,false,false,false)
                    4 => array.from(false,false,false,true,false,false)
                    5 => array.from(false,false,false,false,true,false)
                    6 => array.from(false,false,false,false,false,true)
                [t1,t2,t3,t4,t5,t6] = t.test_cd(cd,bc,xa,xc,ad,pctErr,p_types)
                t1 or t2 or t3 or t4 or t5 or t6
            else
                false
        else
            false
    else
        false

// Check for a valid pivot point D based on the pattern confirmation length parameter (i.e. checking bar_index[t_b])
checkForValidD() =>
    x = bar_index[t_b]          // bar of interest
    bool isLow = true
    bool isHigh = true
    l = low
    h = high
    
    // Validate pivot
    for i=0 to t_b-1            // check bars after potential pivot point
        if l[i] < l[t_b]
            isLow := false
            break    
    if isLow                    // check bars before potential pivot point
        for i=t_b+1 to t_b+3        // need at least 3 bars before 
            if l[i] < l[t_b]
                isLow := false
                break

    for i=0 to t_b-1
        if h[i] > h[t_b]
            isHigh := false
            break
    if isHigh
        for i=t_b+1 to t_b+3
            if h[i] > h[t_b]
                isHigh := false
                break
    
    // Validate pattern (CD leg)
    if isLow or isHigh
        h.xabcd_harmonic[] new = array.new<h.xabcd_harmonic>()
        // Check incomplete patterns
        for p in inc
            if isLow and p.bull
                if validD(p, x, l[t_b])
                    array.push(new, h.init(p.x.x, p.x.y, p.a.x, p.a.y, p.b.x, p.b.y, p.c.x, p.c.y, x, l[t_b], params, p.tp))
            if isHigh and p.bull==false
                if validD(p, x, h[t_b])
                    array.push(new, h.init(p.x.x, p.x.y, p.a.x, p.a.y, p.b.x, p.b.y, p.c.x, p.c.y, x, h[t_b], params, p.tp))
        // Check completed pending patterns
        for p2 in pending
            if isLow and p2.bull
                if validD(p2, x, l[t_b])
                    array.push(new, h.init(p2.x.x, p2.x.y, p2.a.x, p2.a.y, p2.b.x, p2.b.y, p2.c.x, p2.c.y, x, l[t_b], params, p2.tp))
            if isHigh and p2.bull==false
                if validD(p2, x, h[t_b])
                    array.push(new, h.init(p2.x.x, p2.x.y, p2.a.x, p2.a.y, p2.b.x, p2.b.y, p2.c.x, p2.c.y, x, h[t_b], params, p2.tp))

        for n in new
            if not na(n)
                addValidPattern(n)

// find new XABC (potential) pattern
find_pattern(pl,t=true) =>
    if ((t and bullOn) or (t==false and bearOn))
        [f,xX,xY,aX,aY,bX,bY,cX,cY] = t.pat_xabcdIncomplete(t,pl)
        if f and (i_lb==false or bar_index >= last_bar_index-i_lbn)
            [h,h1,h2,h3,h4,h5,h6] = t.harmonic_xabcd_validateIncomplete(xX,xY,aX,aY,bX,bY,cX,cY,pctErr,pctAsym,gartOn,batOn,bflyOn,crabOn,sharkOn,cyphOn)
            if h
                addIncompletePattern(t,h1,h2,h3,h4,h5,h6,xX,xY,aX,aY,bX,bY,cX,cY)
    
// Find XABCD patterns of various pivot lengths
find(bull=true) =>
    // Could probably do this more efficiently with recursion, but Pine prohibits it. Loops are all
    // top-tested though, so it's probably not as expensive as it looks.
    find_pattern(3,bull)
    find_pattern(4,bull)
    find_pattern(5,bull)
    find_pattern(6,bull)
    find_pattern(7,bull)
    find_pattern(8,bull)
    find_pattern(9,bull)
    find_pattern(10,bull)
    find_pattern(11,bull)
    find_pattern(12,bull)
    find_pattern(13,bull)
    find_pattern(14,bull)
    find_pattern(15,bull)
    find_pattern(16,bull)
    find_pattern(17,bull)
    find_pattern(18,bull)
    find_pattern(19,bull)
    find_pattern(20,bull)
    
//-----------------------------------------
// Main
//-----------------------------------------

// update patterns in progress
inc := updateIncompletePatterns()       // update potential/incomplete pattern
pending := updatePendingPatterns()      // update any completed patterns pending results

// find new patterns
find()                      // å°‹æ‰¾çœ‹æ¼²å½¢æ…‹
find(false)                 // å°‹æ‰¾çœ‹è·Œå½¢æ…‹

checkForValidD()

// last bar business
if barstate.islast
    drawFullInProgress()        // draw most recent complete pattern, if still in progress
    printStats()                // compile stats and draw results table